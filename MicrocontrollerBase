/*
 * 
 * Author: Kevin Juneau
 * 
 * Base Station FSK
 * Code to send and receive FSK data to downhole tool
 * 
 */

// todo:
// add additional FIR filters for second set of frequencies
// make receiving data capture signal based on how long bit has been high/low

#include "mcc_generated_files/mcc.h"
#pragma warning disable 520     // warning: (520) function "xyz" is never called  3
#pragma warning disable 1498    // fputc.c:16:: warning: (1498) pointer (unknown)

//defines
#define BIT_PERIOD 0x0000 // period of each bit / time to send one bit
#define FREQUENCY 1000 // frequency for sending data

#define HI_THRESH 80
#define LO_THRESH 40

#define FILTER_SIZE 16 // size of moving average filter
#define BUFFER_SIZE 16 // size of buffer for frequency estimate
#define MESSAGE_SIZE 16 // number of bits in message


#define FUDGE_FACTOR 104 // fudge factor to tune input frequency accuracy

enum READ_STATE
{
    IDLE = 0,
    READ = 1,
    FILTER = 2,
    FILL_MESSAGE = 3
};

//variables
uint8_t amplitude = 5;
uint16_t phaseIncrement;
uint8_t sin[64] =  {128,140,153,165,177,188,199,209,
                    218,227,234,241,246,250,253,255,
                    255,255,253,250,246,241,234,227,
                    218,209,199,188,177,165,153,140,
                    128,115,103, 91, 79, 68, 56, 47,
                     37, 29, 22, 15, 10,  6,  2,  1,
                      0,  1,  2,  6, 10, 15, 22, 29,
                     37, 47, 56, 68, 79, 91,103,115};

// sending flags
bool M = false;
bool generateWave = false;

// receiving flags
bool R = false;
bool newSample = false;
bool receiveMessage = false;
bool bufferFull = false;
bool messageFull = false;

// sending variables
uint16_t messageOut = 0;
bool sendBit;
short sendCode;

// receiving variables
enum READ_STATE currentState = IDLE;
uint16_t bufferIn[BUFFER_SIZE];
bool filterIn[FILTER_SIZE];
uint16_t messageIn = 0;
short receiveCode = 0;

// sending functions
void MainSendData(void);
uint16_t Convert(void);
void TMR0ISR(void);

//receiving functions
void MainReceiveData(void);
uint8_t Filter(void);
void TMR3ISR(void);
void MessageRoutine(void);
void ClearBuffer(void);

//main
void main(void) 
{
    //local variables
    char cmd;
    uint8_t i;

    ADC_Initialize();
    SYSTEM_Initialize();
    
    // Provide Baud rate generator time to stabilize before splash screen
    TMR0_WriteTimer(0xFFFF);
    INTCONbits.TMR0IF = 0;
    while (INTCONbits.TMR0IF == 0);

    TMR0_SetInterruptHandler(TMR0ISR);
    TMR3_SetInterruptHandler(TMR3ISR);
    
    INTERRUPT_GlobalInterruptEnable();    
    INTERRUPT_PeripheralInterruptEnable();

    for (;;) {
        
        MainSendData();
        MainReceiveData();
        
        if (EUSART1_DataReady) 
        { // wait for incoming data on USART
            cmd = EUSART1_Read();
            switch (cmd) 
            { // and do what it tells you to do
                case '?':
                    printf("-------------------------------------------------\r\n");
                    printf("?: help menu\r\n");
                    printf("o: k\r\n");
                    printf("Z: Reset processor\r\n");
                    printf("z: Clear the terminal\r\n");
                    printf("S/s: Start/stop fixed frequency sine wave\r\n");
                    printf("f: enter Frequency\r\n");
                    printf("A/a: increase/decrease Amplitude select amplitude\r\n");
                    printf("M: Enter binary message to send\r\n");
                    printf("R: Receive FSK message\r\n");
                    printf("-------------------------------------------------\r\n");
                    break;
                    
                case 'o':
                    printf("o:	ok\r\n");
                    break;
                   
                case 'Z':
                    for (i = 0; i < 40; i++) printf("\n");
                    RESET();
                    break;
                
                case 'z':
                    for (i = 0; i < 40; i++) printf("\n");
                    break;
                    
                case 'S':
                    generateWave = 1;
                    printf("Generating sine wave.\r\n");
                    break;
                    
                case 's':
                    generateWave = 0;
                    printf("Stopped generating sine wave.\r\n");
                    break;
                    
                case 'f':
                    printf("Enter the new frequency.\r\n");
                    phaseIncrement = 2*Convert();
                    break;
                    
                case 'A':
                    if (amplitude < 15) 
                    {
                        amplitude++;
                        printf("Amplitude is %d/16.\r\n",amplitude);
                    } 
                    else 
                    {
                        printf("Amplitude is already at its maximum.\r\n");
                        printf("Amplitude is %d/16.\r\n",amplitude);
                    }
                    break;
                    
                case 'a':
                    if (amplitude > 1) 
                    {
                        amplitude--;
                        printf("Amplitude is %d/16.\r\n",amplitude);
                    }
                    else 
                    {
                        printf("Amplitude is already at its minimum.\r\n");
                        printf("Amplitude is %d/16.\r\n",amplitude);
                    }
                    break;
                
                case 'M':
                    M = true;
                    break;

                
                case 'R':
                    R = !R;
                    break;
                    
                case 'T':
                    break;
                    
                default:
                    printf("%c is an invalid input.",cmd);
                    break;
                
            }
        }
    }
}

// Gets message from USART, generates FSK wave
void MainSendData(void)
{
    static uint8_t messageIndex = 0;
    static bool getMessage = true;
    if (M)
    {
        if (getMessage)
        {
            printf("Enter send code\r\n");
            messageOut = Convert() << 12; // put sendCode at the first 4 bits
            printf("Enter message\r\n");
            messageOut = messageOut + Convert(); // add message as the last 12 bits
            getMessage = false;
        }
        
        if (messageIndex < 16 && TMR1_HasOverflowOccured())
        {
            sendBit = messageOut & 0x0001;
            messageOut = messageOut >> 1;
            if (sendBit) phaseIncrement = 2*(FREQUENCY + 0.075 * FREQUENCY);
            else phaseIncrement = 2*(FREQUENCY - 0.075 * FREQUENCY);
            generateWave = true;
            TMR1_WriteTimer(BIT_PERIOD);
            messageIndex++;
            
            TEST_PIN_Toggle();
        }
        else if (messageIndex >= 16)
        {
            generateWave = false;
            M = false;
            getMessage = true;
            messageIndex = 0;
        }
    }
    else
    {
        generateWave = false;
    }
}

// Gets multi-digit number as input
uint16_t Convert(void) 
{
    printf("> ");
    uint16_t num = 0;
    char input = '0';
    do {
        num = num * 10;
        num = num + (input - '0');
        input = EUSART1_Read();
        printf("%c",input);
    } while (input != '\r');
    printf("\r\n");
    return num;
}

// DDS ISR
void TMR0ISR(void) 
{
    uint8_t local;
    uint8_t localDiv2, localDiv4, localDiv8, localDiv16;
    uint8_t total = 0;
    uint8_t index = 0;
    static uint16_t phaseAccumulator = 0;
    
    //generate wave
    if (generateWave == 1) 
    {
        phaseAccumulator = phaseAccumulator + phaseIncrement;
        index = phaseAccumulator >> 10;
        local = sin[index];
        localDiv2  = local >> 1;
        localDiv4  = local >> 2;
        localDiv8  = local >> 3;
        localDiv16 = local >> 4;
        total = 0;
        if (amplitude&0b0001) total += localDiv16;
        if (amplitude&0b0010) total += localDiv8;
        if (amplitude&0b0100) total += localDiv4;
        if (amplitude&0b1000) total += localDiv2;
        EPWM1_LoadDutyValue(total);
    } 
    else 
    {
        EPWM1_LoadDutyValue(0x00);
    }
    
    INTCONbits.TMR0IF = 0;
    TMR0_WriteTimer(0x10000-244);
}

// Receive FSK message and convert to integer
void MainReceiveData(void)
{
    // READ variables
    static uint8_t bufferIndex = 0;
    
    // FILTER variables
    static bool oldBit = 0;
    static bool currentBit = 0;
    static uint8_t bitIndex[] = {0,0}; // counts how long bit has {stayed the same, been different}
    static uint8_t bitAverage = 0; // sum of last (FILTER_SIZE) bits
    
    // FILL_MESSAGE variables
    static uint8_t messageIndex = 0;
    
    if (R)
    {
        if (newSample)
        {
            switch (currentState)
            {
                case IDLE:
                    if (ADRESH > HI_THRESH || ADRESH < LO_THRESH)
                    {
                        currentState = READ;
                    }
                    break;
                    
                case FILL_MESSAGE:
                    // shift message and add new bit
                    messageIn = (messageIn << 1) + currentBit;
                    messageIndex++;
                    
                    currentState = READ;
                    
                    if (messageIndex == MESSAGE_SIZE) // full message has been read
                    {
                        messageIndex = 0;
                        
                        bitAverage = 0;
                        bitIndex[0] = 0;
                        bitIndex[1] = 0;
                        
                        bufferIndex = 0;
                        ClearBuffer();
                        
                        receiveCode = (messageIn & 0xF000) >> 12;

                        messageIn = messageIn & 0x0FFF;
                        MessageRoutine();
                        
                        currentState = IDLE;
                    }
                    break;

                case FILTER:
                    // if Filter() outputs 0 and oldBit is 0, no change
                    // if Filter() outputs 1 and oldBit is 0, bitAverage increases
                    // if Filter() outputs 1 and oldBit is 1, no change
                    // if Filter() outputs 0 and oldBit is 1, bitAverage decreases
                    bitAverage += (Filter() - oldBit);
                    
                    if (bitAverage > FILTER_SIZE) bitAverage = FILTER_SIZE;
                    if (bitAverage < 0) bitAverage = 0;
                    
                    currentBit = (bitAverage > FILTER_SIZE/2);
                    // set oldBit for first bit input
                    if (bitIndex[0] == 0)
                    {
                        oldBit = currentBit;
                    }
                    
                    // count how long bit has stayed the same / been different
                    bitIndex[0]++;
                    if (currentBit == oldBit)
                    {
                        bitIndex[1] = 0;
                        if (bitIndex[0] > FILTER_SIZE) // it's been long enough, read bit
                        {
                            currentState = FILL_MESSAGE;
                            bitIndex[0] = 0;
                        }
                        else // not long enough, fill buffer again
                        {
                            currentState = READ;
                        }
                    }
                    else
                    {
                        bitIndex[1]++;
                        if (bitIndex[1] == FILTER_SIZE/2) // bit has been different for long enough, switch bit
                        {
                            oldBit = currentBit;
                            
                            bitIndex[0] = FILTER_SIZE/2;
                            bitIndex[1] = 0;
                        }
                    }

                case READ:
                    // fill buffer
                    bufferIn[bufferIndex] = ADRESH;
                    bufferIndex++;
                    
                    // if buffer full, filter
                    if (bufferIndex == BUFFER_SIZE) 
                    {
                        currentState = FILTER;
                        bufferIndex = 0;
                    }
                    break;
                    
                default:
                    break;
            }
        }
    }
}

// Filtering
uint8_t Filter(void)
{
    // command to generate filters: a = fir1(BUFFER_SIZE-1,[0.15,0.2])
    //                              b = fir1(BUFFER_SIZE-1,[0.2,0.25])
    
    float filterLo[64] = { 0.000393,-0.000348,-0.001283,-0.002205,-0.002738,-0.002387,-0.000731, 0.002260,
                           0.005965, 0.009064, 0.009859, 0.006946, 0.000000,-0.009656,-0.019076,-0.024455,
                          -0.022503,-0.011950, 0.005433, 0.024861, 0.039785, 0.044085, 0.034470, 0.012142,
                          -0.017024,-0.044049,-0.059741,-0.057947,-0.037972,-0.005185, 0.030499, 0.057843,
                           0.068060, 0.057843, 0.030499,-0.005185,-0.037972,-0.057947,-0.059741,-0.044049,
                          -0.017024, 0.012142, 0.034470, 0.044085, 0.039785, 0.024861, 0.005433,-0.011950,
                          -0.022503,-0.024455,-0.019076,-0.009656, 0.000000, 0.006946, 0.009859, 0.009064,
                           0.005965, 0.002260,-0.000731,-0.002387,-0.002738,-0.002205,-0.001283,-0.000348,
                           0.000393};
    float filterHi[64] = {-0.001028,-0.001485,-0.001280,-0.000177, 0.001689, 0.003567, 0.004160, 0.002255,
                          -0.002274,-0.007738,-0.010909,-0.008618, 0.000000, 0.011980, 0.021107, 0.020877,
                           0.008579,-0.011928,-0.030889,-0.037155,-0.024543, 0.003550, 0.034407, 0.051760,
                           0.044488, 0.013498,-0.027409,-0.057841,-0.061328,-0.034472, 0.010490, 0.051491,
                           0.067936, 0.051491, 0.010490,-0.034472,-0.061328,-0.057841,-0.027409, 0.013498,
                           0.044488, 0.051760, 0.034407, 0.003550,-0.024543,-0.037155,-0.030889,-0.011928,
                           0.008579, 0.020877, 0.021107, 0.011980, 0.000000,-0.008618,-0.010909,-0.007738,
                          -0.002274, 0.002255, 0.004160, 0.003567, 0.001689,-0.000177,-0.001280,-0.001485,
                          -0.001028};
    
    float hiVal = 0;
    float loVal = 0;
    for (int i = 0; i < 64; i++)
    {
        hiVal += filterHi[i] * bufferIn[i];
        loVal += filterLo[i] * bufferIn[i];
    }
    if (hiVal < 0) hiVal *= -1;
    if (loVal < 0) loVal *= -1;
    
    return (hiVal > loVal);
}

void TMR3ISR(void)
{
    ADCON0bits.GO_NOT_DONE = 1;
    newSample = true;
    TMR3_WriteTimer(0xe8f0); //tune if needed
}

// Deal with message
void MessageRoutine(void)
{
    printf("Code: %X    Message: %X\r\n",receiveCode,messageIn);
    // code for surface microcontroller
    if (true)
    {
        
        switch (receiveCode)
        {
            case 0:
                break;
                
            case 1:
                printf("Temperature: %d\r\n",messageIn);
                break;
                
            case 2:
                printf("Unit Status: %d\r\n",messageIn);
                break;
                
            default:
                printf("Code: %d Message: %d\r\n",receiveCode,messageIn);
                break;
        }
        
    }
    // code for downhole microcontroller
    if (false) 
    {
        
        switch (receiveCode)
        {
            case 0:
                break;
                
            case 1: // set pins
                break;
                
            case 2: // send temperature data
                break;
                
            default:
                break;
                
        }
        
    }
}

void ClearBuffer(void)
{
    for (uint8_t i = 0; i < BUFFER_SIZE; i++)
    {
        bufferIn[i] = 0;
    }
}
